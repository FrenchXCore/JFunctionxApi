/*
 * Cosmos SDK - gRPC Gateway docs
 * A REST interface for state queries
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package eu.frenchxcore.model.cosmossdk.openapi;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import eu.frenchxcore.model.cosmossdk.openapi.CosmosTxV1beta1AuthInfoFee;
import eu.frenchxcore.model.cosmossdk.openapi.CosmosTxV1beta1SignerInfo;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * AuthInfo describes the fee and signer modes that are used to sign a transaction.
 */
@ApiModel(description = "AuthInfo describes the fee and signer modes that are used to sign a transaction.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-06-28T00:22:37.119222300+02:00[Europe/Paris]")
public class CosmosTxV1beta1AuthInfo {
  public static final String SERIALIZED_NAME_SIGNER_INFOS = "signer_infos";
  @SerializedName(SERIALIZED_NAME_SIGNER_INFOS)
  private List<CosmosTxV1beta1SignerInfo> signerInfos = null;

  public static final String SERIALIZED_NAME_FEE = "fee";
  @SerializedName(SERIALIZED_NAME_FEE)
  private CosmosTxV1beta1AuthInfoFee fee;


  public CosmosTxV1beta1AuthInfo signerInfos(List<CosmosTxV1beta1SignerInfo> signerInfos) {
    
    this.signerInfos = signerInfos;
    return this;
  }

  public CosmosTxV1beta1AuthInfo addSignerInfosItem(CosmosTxV1beta1SignerInfo signerInfosItem) {
    if (this.signerInfos == null) {
      this.signerInfos = new ArrayList<CosmosTxV1beta1SignerInfo>();
    }
    this.signerInfos.add(signerInfosItem);
    return this;
  }

   /**
   * signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody&#39;s messages. The first element is the primary signer and the one which pays the fee.
   * @return signerInfos
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.")

  public List<CosmosTxV1beta1SignerInfo> getSignerInfos() {
    return signerInfos;
  }


  public void setSignerInfos(List<CosmosTxV1beta1SignerInfo> signerInfos) {
    this.signerInfos = signerInfos;
  }


  public CosmosTxV1beta1AuthInfo fee(CosmosTxV1beta1AuthInfoFee fee) {
    
    this.fee = fee;
    return this;
  }

   /**
   * Get fee
   * @return fee
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CosmosTxV1beta1AuthInfoFee getFee() {
    return fee;
  }


  public void setFee(CosmosTxV1beta1AuthInfoFee fee) {
    this.fee = fee;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CosmosTxV1beta1AuthInfo cosmosTxV1beta1AuthInfo = (CosmosTxV1beta1AuthInfo) o;
    return Objects.equals(this.signerInfos, cosmosTxV1beta1AuthInfo.signerInfos) &&
        Objects.equals(this.fee, cosmosTxV1beta1AuthInfo.fee);
  }

  @Override
  public int hashCode() {
    return Objects.hash(signerInfos, fee);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CosmosTxV1beta1AuthInfo {\n");
    sb.append("    signerInfos: ").append(toIndentedString(signerInfos)).append("\n");
    sb.append("    fee: ").append(toIndentedString(fee)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

