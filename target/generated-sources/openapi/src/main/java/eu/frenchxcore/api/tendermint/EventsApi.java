/*
 * Tendermint RPC
 * Tendermint supports the following RPC protocols:  * URI over HTTP * JSON-RPC 2.0 over HTTP * JSON-RPC 2.0 over websockets (deprecated)  ## Configuration  RPC can be configured by tuning parameters under `[rpc]` table in the `$TMHOME/config/config.toml` file or by using the `--rpc.X` command-line flags.  Default rpc listen address is `tcp://0.0.0.0:26657`. To set another address, set the `laddr` config parameter to desired value. CORS (Cross-Origin Resource Sharing) can be enabled by setting `cors_allowed_origins`, `cors_allowed_methods`, `cors_allowed_headers` config parameters.  ## Arguments  Arguments which expect strings or byte arrays may be passed as quoted strings, like `\"abc\"` or as `0x`-prefixed strings, like `0x616263`.  ## URI/HTTP  A GET request with arguments encoded as query parameters:      curl localhost:26657/block?height=5  ## JSONRPC/HTTP  JSONRPC requests can be POST'd to the root RPC endpoint via HTTP.      curl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' localhost:26657  ## JSONRPC/websockets  In Tendermint v0.35 and earlier, JSONRPC requests can be also made via websocket.  The websocket interface is deprecated in Tendermint v0.36, and will be removed in v0.37.  The websocket endpoint is at `/websocket`, e.g. `localhost:26657/websocket`. The RPC methods for event subscription (`subscribe`, `unsubscribe`, and `unsubscribe_all`) are only available via websockets.  Example using https://github.com/hashrocket/ws:      ws ws://localhost:26657/websocket     > { \"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": [\"tm.event='NewBlock'\"], \"id\": 1 } 
 *
 * The version of the OpenAPI document: Master
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package eu.frenchxcore.api.tendermint;

import eu.frenchxcore.api.ApiCallback;
import eu.frenchxcore.api.ApiClient;
import eu.frenchxcore.api.ApiException;
import eu.frenchxcore.api.ApiResponse;
import eu.frenchxcore.api.Configuration;
import eu.frenchxcore.api.Pair;
import eu.frenchxcore.api.ProgressRequestBody;
import eu.frenchxcore.api.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import eu.frenchxcore.model.tendermint.openapi.EmptyResponse;
import eu.frenchxcore.model.tendermint.openapi.ErrorResponse;
import eu.frenchxcore.model.tendermint.openapi.EventFilter;
import eu.frenchxcore.model.tendermint.openapi.EventsResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EventsApi {
    private ApiClient localVarApiClient;

    public EventsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public EventsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for events
     * @param filter  (optional)
     * @param maxItems  (optional)
     * @param after  (optional)
     * @param before  (optional)
     * @param waitTime  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reports a batch of matching events </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Reports an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call eventsCall(EventFilter filter, Integer maxItems, String after, String before, Integer waitTime, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (maxItems != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxItems", maxItems));
        }

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (before != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("before", before));
        }

        if (waitTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("waitTime", waitTime));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call eventsValidateBeforeCall(EventFilter filter, Integer maxItems, String after, String before, Integer waitTime, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = eventsCall(filter, maxItems, after, before, waitTime, _callback);
        return localVarCall;

    }

    /**
     * Fetch events posted by the consensus node.
     * Fetch a batch of events posted by the consensus node and matching a specified query.  The query grammar is defined in https://godoc.org/github.com/tendermint/tendermint/internal/pubsub/query/syntax. An empty query matches all events; otherwise a query comprises one or more terms comparing event metadata to target values. For example, to select new block events:      tm.event &#x3D; &#39;NewBlock&#39;  Multiple terms can be combined with AND, for example to match the transaction event with a given hash, use:      tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;EA7B33F&#39;  The comparison operators include \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, and \&quot;CONTAINS\&quot;. Operands may be strings (in single quotes), numbers, dates, or timestamps. In addition, the \&quot;EXISTS\&quot; operator allows you to check for the presence of an attribute regardless of its value.  Tendermint defines a tm.event attribute for all events. Transactions are also assigned tx.hash and tx.height attributes. Other attributes are provided by the application as ABCI Event records. The name of the event in the query is formed by combining the type and attribute key with a period. For example, given:      []abci.Event{{         Type: \&quot;reward\&quot;,         Attributes: []abci.EventAttribute{             {Key: \&quot;address\&quot;, Value: \&quot;cosmos1xyz012pdq\&quot;},             {Key: \&quot;amount\&quot;, Value: \&quot;45.62\&quot;},             {Key: \&quot;balance\&quot;, Value: \&quot;100.390001\&quot;},         },     }}  the query may refer to the names \&quot;reward.address\&quot;, \&quot;reward.amount\&quot;, and \&quot;reward.balance\&quot;, as in:      reward.address EXISTS AND reward.balance &gt; 45  The node maintains a log of all events within an operator-defined time window. The /events method returns the most recent items from the log that match the query. Each item returned includes a cursor that marks its location in the log. Cursors can be passed via the \&quot;before\&quot; and \&quot;after\&quot; parameters to fetch events earlier in the log. 
     * @param filter  (optional)
     * @param maxItems  (optional)
     * @param after  (optional)
     * @param before  (optional)
     * @param waitTime  (optional)
     * @return EventsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reports a batch of matching events </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Reports an error </td><td>  -  </td></tr>
     </table>
     */
    public EventsResponse events(EventFilter filter, Integer maxItems, String after, String before, Integer waitTime) throws ApiException {
        ApiResponse<EventsResponse> localVarResp = eventsWithHttpInfo(filter, maxItems, after, before, waitTime);
        return localVarResp.getData();
    }

    /**
     * Fetch events posted by the consensus node.
     * Fetch a batch of events posted by the consensus node and matching a specified query.  The query grammar is defined in https://godoc.org/github.com/tendermint/tendermint/internal/pubsub/query/syntax. An empty query matches all events; otherwise a query comprises one or more terms comparing event metadata to target values. For example, to select new block events:      tm.event &#x3D; &#39;NewBlock&#39;  Multiple terms can be combined with AND, for example to match the transaction event with a given hash, use:      tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;EA7B33F&#39;  The comparison operators include \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, and \&quot;CONTAINS\&quot;. Operands may be strings (in single quotes), numbers, dates, or timestamps. In addition, the \&quot;EXISTS\&quot; operator allows you to check for the presence of an attribute regardless of its value.  Tendermint defines a tm.event attribute for all events. Transactions are also assigned tx.hash and tx.height attributes. Other attributes are provided by the application as ABCI Event records. The name of the event in the query is formed by combining the type and attribute key with a period. For example, given:      []abci.Event{{         Type: \&quot;reward\&quot;,         Attributes: []abci.EventAttribute{             {Key: \&quot;address\&quot;, Value: \&quot;cosmos1xyz012pdq\&quot;},             {Key: \&quot;amount\&quot;, Value: \&quot;45.62\&quot;},             {Key: \&quot;balance\&quot;, Value: \&quot;100.390001\&quot;},         },     }}  the query may refer to the names \&quot;reward.address\&quot;, \&quot;reward.amount\&quot;, and \&quot;reward.balance\&quot;, as in:      reward.address EXISTS AND reward.balance &gt; 45  The node maintains a log of all events within an operator-defined time window. The /events method returns the most recent items from the log that match the query. Each item returned includes a cursor that marks its location in the log. Cursors can be passed via the \&quot;before\&quot; and \&quot;after\&quot; parameters to fetch events earlier in the log. 
     * @param filter  (optional)
     * @param maxItems  (optional)
     * @param after  (optional)
     * @param before  (optional)
     * @param waitTime  (optional)
     * @return ApiResponse&lt;EventsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reports a batch of matching events </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Reports an error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EventsResponse> eventsWithHttpInfo(EventFilter filter, Integer maxItems, String after, String before, Integer waitTime) throws ApiException {
        okhttp3.Call localVarCall = eventsValidateBeforeCall(filter, maxItems, after, before, waitTime, null);
        Type localVarReturnType = new TypeToken<EventsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch events posted by the consensus node. (asynchronously)
     * Fetch a batch of events posted by the consensus node and matching a specified query.  The query grammar is defined in https://godoc.org/github.com/tendermint/tendermint/internal/pubsub/query/syntax. An empty query matches all events; otherwise a query comprises one or more terms comparing event metadata to target values. For example, to select new block events:      tm.event &#x3D; &#39;NewBlock&#39;  Multiple terms can be combined with AND, for example to match the transaction event with a given hash, use:      tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;EA7B33F&#39;  The comparison operators include \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, and \&quot;CONTAINS\&quot;. Operands may be strings (in single quotes), numbers, dates, or timestamps. In addition, the \&quot;EXISTS\&quot; operator allows you to check for the presence of an attribute regardless of its value.  Tendermint defines a tm.event attribute for all events. Transactions are also assigned tx.hash and tx.height attributes. Other attributes are provided by the application as ABCI Event records. The name of the event in the query is formed by combining the type and attribute key with a period. For example, given:      []abci.Event{{         Type: \&quot;reward\&quot;,         Attributes: []abci.EventAttribute{             {Key: \&quot;address\&quot;, Value: \&quot;cosmos1xyz012pdq\&quot;},             {Key: \&quot;amount\&quot;, Value: \&quot;45.62\&quot;},             {Key: \&quot;balance\&quot;, Value: \&quot;100.390001\&quot;},         },     }}  the query may refer to the names \&quot;reward.address\&quot;, \&quot;reward.amount\&quot;, and \&quot;reward.balance\&quot;, as in:      reward.address EXISTS AND reward.balance &gt; 45  The node maintains a log of all events within an operator-defined time window. The /events method returns the most recent items from the log that match the query. Each item returned includes a cursor that marks its location in the log. Cursors can be passed via the \&quot;before\&quot; and \&quot;after\&quot; parameters to fetch events earlier in the log. 
     * @param filter  (optional)
     * @param maxItems  (optional)
     * @param after  (optional)
     * @param before  (optional)
     * @param waitTime  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Reports a batch of matching events </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Reports an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call eventsAsync(EventFilter filter, Integer maxItems, String after, String before, Integer waitTime, final ApiCallback<EventsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = eventsValidateBeforeCall(filter, maxItems, after, before, waitTime, _callback);
        Type localVarReturnType = new TypeToken<EventsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for subscribe
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subscribeCall(String query, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscribe";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call subscribeValidateBeforeCall(String query, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling subscribe(Async)");
        }
        

        okhttp3.Call localVarCall = subscribeCall(query, _callback);
        return localVarCall;

    }

    /**
     * Subscribe for events via WebSocket.
     * To tell which events you want, you need to provide a query. query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot; AND \&quot;EXISTS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  Examples:       tm.event &#x3D; &#39;NewBlock&#39;               # new blocks       tm.event &#x3D; &#39;CompleteProposal&#39;       # node got a complete proposal       tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;XYZ&#39; # single transaction       tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 5   # all txs of the fifth block       tx.height &#x3D; 5                       # all txs of the fifth block  Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height. Note for transactions, you can define additional keys by providing events with DeliverTx response.  import (     abci \&quot;github.com/tendermint/tendermint/abci/types\&quot;     \&quot;github.com/tendermint/tendermint/libs/pubsub/query\&quot; )  abci.ResponseDeliverTx{   Events: []abci.Event{       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrA\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcX\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrB\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcY\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;transfer\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;sender\&quot;, Value: \&quot;AddrC\&quot;, Index: true},               {Key: \&quot;recipient\&quot;, Value: \&quot;AddrD\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },   }, }  All events are indexed by a composite key of the form {eventType}.{evenAttrKey}. In the above examples, the following keys would be indexed:    - rewards.withdraw.address    - rewards.withdraw.source    - rewards.withdraw.amount    - rewards.withdraw.balance    - transfer.sender    - transfer.recipient    - transfer.amount  Multiple event types with duplicate keys are allowed and are meant to categorize unique and distinct events. In the above example, all events indexed under the key &#x60;rewards.withdraw.address&#x60; will have the following values stored and queryable:     - AddrA    - AddrB  To create a query for txs where address AddrA withdrew rewards: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39;\&quot;)  To create a query for txs where address AddrA withdrew rewards from source Y: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39; AND rewards.withdraw.source &#x3D; &#39;Y&#39;\&quot;)  To create a query for txs where AddrA transferred funds: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrA&#39;\&quot;)  The following queries would return no results: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.source &#x3D; &#39;W&#39;\&quot;)  See list of all possible events here https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants  For complete query syntax, check out https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.  &#x60;&#x60;&#x60;go import rpchttp \&quot;github.com/tendermint/rpc/client/http\&quot; import \&quot;github.com/tendermint/tendermint/types\&quot;  client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err &#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 1 * time.Second) defer cancel() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; txs, err :&#x3D; client.Subscribe(ctx, \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error }  go func() {  for e :&#x3D; range txs {    fmt.Println(\&quot;got \&quot;, e.Data.(types.EventDataTx))    } }() &#x60;&#x60;&#x60;  NOTE: if you&#39;re not reading events fast enough, Tendermint might terminate the subscription. 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @return EmptyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public EmptyResponse subscribe(String query) throws ApiException {
        ApiResponse<EmptyResponse> localVarResp = subscribeWithHttpInfo(query);
        return localVarResp.getData();
    }

    /**
     * Subscribe for events via WebSocket.
     * To tell which events you want, you need to provide a query. query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot; AND \&quot;EXISTS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  Examples:       tm.event &#x3D; &#39;NewBlock&#39;               # new blocks       tm.event &#x3D; &#39;CompleteProposal&#39;       # node got a complete proposal       tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;XYZ&#39; # single transaction       tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 5   # all txs of the fifth block       tx.height &#x3D; 5                       # all txs of the fifth block  Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height. Note for transactions, you can define additional keys by providing events with DeliverTx response.  import (     abci \&quot;github.com/tendermint/tendermint/abci/types\&quot;     \&quot;github.com/tendermint/tendermint/libs/pubsub/query\&quot; )  abci.ResponseDeliverTx{   Events: []abci.Event{       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrA\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcX\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrB\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcY\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;transfer\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;sender\&quot;, Value: \&quot;AddrC\&quot;, Index: true},               {Key: \&quot;recipient\&quot;, Value: \&quot;AddrD\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },   }, }  All events are indexed by a composite key of the form {eventType}.{evenAttrKey}. In the above examples, the following keys would be indexed:    - rewards.withdraw.address    - rewards.withdraw.source    - rewards.withdraw.amount    - rewards.withdraw.balance    - transfer.sender    - transfer.recipient    - transfer.amount  Multiple event types with duplicate keys are allowed and are meant to categorize unique and distinct events. In the above example, all events indexed under the key &#x60;rewards.withdraw.address&#x60; will have the following values stored and queryable:     - AddrA    - AddrB  To create a query for txs where address AddrA withdrew rewards: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39;\&quot;)  To create a query for txs where address AddrA withdrew rewards from source Y: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39; AND rewards.withdraw.source &#x3D; &#39;Y&#39;\&quot;)  To create a query for txs where AddrA transferred funds: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrA&#39;\&quot;)  The following queries would return no results: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.source &#x3D; &#39;W&#39;\&quot;)  See list of all possible events here https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants  For complete query syntax, check out https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.  &#x60;&#x60;&#x60;go import rpchttp \&quot;github.com/tendermint/rpc/client/http\&quot; import \&quot;github.com/tendermint/tendermint/types\&quot;  client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err &#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 1 * time.Second) defer cancel() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; txs, err :&#x3D; client.Subscribe(ctx, \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error }  go func() {  for e :&#x3D; range txs {    fmt.Println(\&quot;got \&quot;, e.Data.(types.EventDataTx))    } }() &#x60;&#x60;&#x60;  NOTE: if you&#39;re not reading events fast enough, Tendermint might terminate the subscription. 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @return ApiResponse&lt;EmptyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EmptyResponse> subscribeWithHttpInfo(String query) throws ApiException {
        okhttp3.Call localVarCall = subscribeValidateBeforeCall(query, null);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Subscribe for events via WebSocket. (asynchronously)
     * To tell which events you want, you need to provide a query. query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot; AND \&quot;EXISTS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  Examples:       tm.event &#x3D; &#39;NewBlock&#39;               # new blocks       tm.event &#x3D; &#39;CompleteProposal&#39;       # node got a complete proposal       tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;XYZ&#39; # single transaction       tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 5   # all txs of the fifth block       tx.height &#x3D; 5                       # all txs of the fifth block  Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height. Note for transactions, you can define additional keys by providing events with DeliverTx response.  import (     abci \&quot;github.com/tendermint/tendermint/abci/types\&quot;     \&quot;github.com/tendermint/tendermint/libs/pubsub/query\&quot; )  abci.ResponseDeliverTx{   Events: []abci.Event{       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrA\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcX\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;address\&quot;, Value: \&quot;AddrB\&quot;, Index: true},               {Key: \&quot;source\&quot;, Value: \&quot;SrcY\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},               {Key: \&quot;balance\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },       {           Type: \&quot;transfer\&quot;,           Attributes: []abci.EventAttribute{               {Key: \&quot;sender\&quot;, Value: \&quot;AddrC\&quot;, Index: true},               {Key: \&quot;recipient\&quot;, Value: \&quot;AddrD\&quot;, Index: true},               {Key: \&quot;amount\&quot;, Value: \&quot;...\&quot;, Index: true},           },       },   }, }  All events are indexed by a composite key of the form {eventType}.{evenAttrKey}. In the above examples, the following keys would be indexed:    - rewards.withdraw.address    - rewards.withdraw.source    - rewards.withdraw.amount    - rewards.withdraw.balance    - transfer.sender    - transfer.recipient    - transfer.amount  Multiple event types with duplicate keys are allowed and are meant to categorize unique and distinct events. In the above example, all events indexed under the key &#x60;rewards.withdraw.address&#x60; will have the following values stored and queryable:     - AddrA    - AddrB  To create a query for txs where address AddrA withdrew rewards: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39;\&quot;)  To create a query for txs where address AddrA withdrew rewards from source Y: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39; AND rewards.withdraw.source &#x3D; &#39;Y&#39;\&quot;)  To create a query for txs where AddrA transferred funds: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrA&#39;\&quot;)  The following queries would return no results: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.source &#x3D; &#39;W&#39;\&quot;)  See list of all possible events here https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants  For complete query syntax, check out https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.  &#x60;&#x60;&#x60;go import rpchttp \&quot;github.com/tendermint/rpc/client/http\&quot; import \&quot;github.com/tendermint/tendermint/types\&quot;  client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err &#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 1 * time.Second) defer cancel() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; txs, err :&#x3D; client.Subscribe(ctx, \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error }  go func() {  for e :&#x3D; range txs {    fmt.Println(\&quot;got \&quot;, e.Data.(types.EventDataTx))    } }() &#x60;&#x60;&#x60;  NOTE: if you&#39;re not reading events fast enough, Tendermint might terminate the subscription. 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call subscribeAsync(String query, final ApiCallback<EmptyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = subscribeValidateBeforeCall(query, _callback);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for unsubscribe
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call unsubscribeCall(String query, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/unsubscribe";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unsubscribeValidateBeforeCall(String query, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling unsubscribe(Async)");
        }
        

        okhttp3.Call localVarCall = unsubscribeCall(query, _callback);
        return localVarCall;

    }

    /**
     * Unsubscribe from event on Websocket
     * &#x60;&#x60;&#x60;go client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err :&#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; err &#x3D; client.Unsubscribe(context.Background(), \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error } &#x60;&#x60;&#x60; 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @return EmptyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public EmptyResponse unsubscribe(String query) throws ApiException {
        ApiResponse<EmptyResponse> localVarResp = unsubscribeWithHttpInfo(query);
        return localVarResp.getData();
    }

    /**
     * Unsubscribe from event on Websocket
     * &#x60;&#x60;&#x60;go client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err :&#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; err &#x3D; client.Unsubscribe(context.Background(), \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error } &#x60;&#x60;&#x60; 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @return ApiResponse&lt;EmptyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EmptyResponse> unsubscribeWithHttpInfo(String query) throws ApiException {
        okhttp3.Call localVarCall = unsubscribeValidateBeforeCall(query, null);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Unsubscribe from event on Websocket (asynchronously)
     * &#x60;&#x60;&#x60;go client, err :&#x3D; rpchttp.New(\&quot;tcp://0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) if err !&#x3D; nil {   // handle error }  err :&#x3D; client.Start() if err !&#x3D; nil {   // handle error } defer client.Stop() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; err &#x3D; client.Unsubscribe(context.Background(), \&quot;test-client\&quot;, query) if err !&#x3D; nil {   // handle error } &#x60;&#x60;&#x60; 
     * @param query query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call unsubscribeAsync(String query, final ApiCallback<EmptyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = unsubscribeValidateBeforeCall(query, _callback);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for unsubscribeAll
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call unsubscribeAllCall(final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/unsubscribe_all";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unsubscribeAllValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = unsubscribeAllCall(_callback);
        return localVarCall;

    }

    /**
     * Unsubscribe from all events via WebSocket
     * Unsubscribe from all events via WebSocket 
     * @return EmptyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public EmptyResponse unsubscribeAll() throws ApiException {
        ApiResponse<EmptyResponse> localVarResp = unsubscribeAllWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Unsubscribe from all events via WebSocket
     * Unsubscribe from all events via WebSocket 
     * @return ApiResponse&lt;EmptyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EmptyResponse> unsubscribeAllWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = unsubscribeAllValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Unsubscribe from all events via WebSocket (asynchronously)
     * Unsubscribe from all events via WebSocket 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> empty answer </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> empty error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call unsubscribeAllAsync(final ApiCallback<EmptyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = unsubscribeAllValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<EmptyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
